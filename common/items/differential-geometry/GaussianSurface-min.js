import{Vector2,Vector3}from"../../../3party/three/build/three.module.js";import{globals}from"../../World/globals.js";import{ComputeSystem}from"../../gpu/ComputeSystem.js";import{ComputeMaterial}from"../../materials/ComputeMaterial.js";import{colorConversion}from"../../shaders/colors/colorConversion.js";import{LinearFilter,NearestFilter}from"../../../3party/three/build/three.module.js";import{IntegralCurve}from"../../components/odes/IntegralCurve-Traditional.js";import{State,dState}from"../../cpu/components/State.js";import{RungeKutta}from"../../cpu/RungeKutta.js";import IntegralCurveSpray from"../../components/odes/IntegralCurveSpray-Traditional.js";let equations={x:"u",y:"v",z:"a*exp(-b*(u*u+v*v))"},domain={uMin:-3.14,uMax:3.14,vMin:-3.14,vMax:3.14},buildPointShader=()=>`\n            void main(){\n\n                 vec2 uv = gl_FragCoord.xy/res;\n                 \n                 float u = (float(${domain.uMax})-float(${domain.uMin}))/0.97*uv.x+float(${domain.uMin});\n                 float v = (float(${domain.vMax})-float(${domain.vMin}))/0.97*uv.y+float(${domain.vMin});\n                 \n                 float x = ${equations.x};\n                 float y = ${equations.z};\n                 float z = ${equations.y};\n                 \n                 vec3 pos = vec3(x,y,z);\n                \n                 gl_FragColor = vec4(pos,1.);\n            }\n        `;const parameterization=e=>{let n=e.x,t=e.y,a=n,r=t,o=1*Math.exp(-2*(n*n+t*t));return new Vector3(a,o,r)},accel=e=>{let n=e.pos.x,t=e.pos.y,a=e.vel.x,r=e.vel.y,o=16*(a*a*(4*n*n-1)+r*r*(4*t*t-1)+8*n*t*a*r)/(16*(n*n+t*t)+Math.exp(4*(n*n+t*t))),i=new Vector2(n,t);return i.multiplyScalar(o),i},fetch="\n    vec3 fetch(sampler2D tex, ivec2 ij) {\n\n        return texelFetch(tex, ij, 0).xyz;\n    }\n    ",derivativeCalc="\n\n            vec3 texDerivativeCentral(sampler2D tex, ivec2 ij, ivec2 dir){\n                vec3 value0 = fetch( tex, ij - dir );\n                vec3 value1 = fetch( tex, ij + dir );\n                \n                float ep;\n                if(dir.x==1){\n                    ep=1./res.x;\n                }\n                else{\n                    ep=1./res.y;\n                }\n\n                float h = 2.*ep;\n                \n                vec3 tang = ( value1 - value0 ) / h;\n                \n                return tang;\n            }\n                \n            vec3 texDerivativeRight(sampler2D tex, ivec2 ij, ivec2 dir){\n          \n            \n                vec3 value0 = fetch( tex, ij  );\n                vec3 value1 = fetch( tex, ij + dir );\n                \n                float ep;\n                if(dir.x==1){\n                    ep=1./res.x;\n                }\n                else{\n                    ep=1./res.y;\n                }\n\n                float h = ep;\n                \n                vec3 tang = ( value1 - value0 ) / h;\n                \n                return tang;\n            }\n            \n            vec3 texDerivativeLeft(sampler2D tex, ivec2 ij, ivec2 dir){\n            \n                vec3 value0 = fetch( tex, ij -dir  );\n                vec3 value1 = fetch( tex, ij  );\n                \n                float ep;\n                if(dir.x==1){\n                    ep=1./res.x;\n                }\n                else{\n                    ep=1./res.y;\n                }\n\n                float h = ep;\n                \n                vec3 tang = ( value1 - value0 ) / h;\n                \n                return tang;\n            }\n            \n            \n\n            vec3 texDerivative( sampler2D tex, ivec2 ij, ivec2 dir ){\n                //need to worry about edge cases: what happens at the boundary of the texture?\n                return texDerivativeRight(tex,ij,dir);\n            }\n        ",tangentUShader=fetch+derivativeCalc+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            ivec2 dir = ivec2(1,0);\n            \n            vec3 posU = texDerivative(point, ij, dir);\n            \n            gl_FragColor = vec4(posU,0);\n        }\n        ",tangentVShader=fetch+derivativeCalc+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            ivec2 dir = ivec2(0,1);\n            \n            vec3 posV = texDerivative(point, ij, dir);\n            \n            gl_FragColor = vec4(posV,0);\n        }\n        ",normalVecShader=fetch+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            \n            vec3 tU = fetch(tangentU, ij);\n            vec3 tV = fetch(tangentV, ij);\n           \n            vec3 nVec = cross( tU, tV );\n            nVec = normalize( nVec );\n            \n            gl_FragColor=vec4(nVec, 0.);\n        }\n        ",firstFFShader=fetch+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            \n            vec3 tU = fetch(tangentU, ij);\n            vec3 tV = fetch(tangentV, ij);\n            \n            float E = dot( tU, tU );\n            float F = dot( tU, tV );\n            float G = dot( tV, tV );\n            \n            vec3 I = vec3(E,F,G);\n            \n            gl_FragColor=vec4( I, 0. );\n        }\n        ",secondFFShader=fetch+derivativeCalc+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            ivec2 eU = ivec2(1,0);\n            ivec2 eV = ivec2(0,1);\n           \n           //get the normal vector\n            vec3 nVec = fetch(normalVec, ij);\n            \n            //compute the second derivatives of the parameterization:\n            vec3 posUU = texDerivative(tangentU, ij, eU);\n            vec3 posUV = texDerivative(tangentU, ij, eV);\n            vec3 posVV = texDerivative(tangentV, ij, eV);\n            \n            float L = dot( posUU, nVec );\n            float M = dot( posUV, nVec );\n            float N = dot( posVV, nVec );\n            \n            vec3 II = vec3(L, M, N);\n            \n            gl_FragColor=vec4( II, 0. );\n        }\n        ",curvatureShader=fetch+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            \n            vec3 I = fetch(firstFF, ij);\n            float E = I.x;\n            float F = I.y;\n            float G = I.z;\n            \n            vec3 II = fetch(secondFF, ij);\n            float L = II.x;\n            float M = II.y;\n            float N = II.z;\n            \n            float gaussCurvature = (L*N-M*M)/(E*G-F*F);\n            \n            float meanCurvature = (E*N-2.*F*M+G*L)/(2.*(E*G-F*F));\n            \n            gl_FragColor = vec4( gaussCurvature, meanCurvature, 0, 0);\n        }\n        ",variables=["point","tangentU","tangentV","normalVec","firstFF","secondFF","curvature"],shaders={point:buildPointShader,tangentU:tangentUShader,tangentV:tangentVShader,normalVec:normalVecShader,firstFF:firstFFShader,secondFF:secondFFShader,curvature:curvatureShader},uniforms={a:{type:"float",value:1,range:[0,2,.01]},b:{type:"float",value:2,range:[1,3,.01]},c:{type:"float",value:0,range:[-1,1,.01]}},options={res:[256,256],filter:LinearFilter};let computer=new ComputeSystem(variables,shaders,uniforms,options,globals.renderer);computer.setName("Parameters");const vertAux="",displace="\nvec3 displace( vec2 uv ){\n    return texture(point, uv).xyz;\n}\n",nVec="\n    vec3 nVec( vec2 uv ){\n        return texture(normalVec, uv).xyz;\n    }\n",fragAux=colorConversion,fragColor="\n            vec3 fragColor(){\n            \n            vec3 col;\n            float curv;\n            \n            //first: if we are gaussian mor mean curvature:\n            if(coloration < 2) {\n            \n            if( coloration == 0 ){\n                curv = texture(curvature, vUv).x;\n            }\n            if( coloration ==1 ){\n                 curv = texture(curvature, vUv).y;\n            }\n\n            float k = 2./3.1415*atan(2.*curv);\n            \n            float hue = 1.-(1.+k)/2.-0.2;\n\n            float sat = 0.5;\n           // sat =0.25*abs(k)+0.25;\n           \n           //change lightness to get dark areas:\n           float mag=1.;\n           if(equipotentials){\n                mag = 0.15*(pow(abs(sin(20.*k)),30.))+0.9;\n           }\n\n            col = hsb2rgb(vec3(hue, sat, 0.5*mag));\n            \n          }\n            \n         //otherwise, we are the gauss map:\n         //assign colors based on a sphere: white = north pole, black = south pole, hue = longitude   \n         else{\n         \n            vec3 nVec = texture(normalVec, vUv).xyz;\n            float phi = acos(nVec.z);\n            float theta = atan(nVec.y, nVec.x);\n            \n            float hue = theta/6.29;\n            float lightness = 0.5*phi/3.14+0.2;\n            float sat = 0.6*sin(phi);\n            \n           //equipotentials give spherical grid:\n           float mag=1.;\n           if(equipotentials){\n                float thetaLines = abs(sin(20.*theta));\n                float phiLines = abs(sin(20.*phi));\n                mag = 0.1*(pow(phiLines,30.))+0.1*(pow(thetaLines,30.))+0.9;\n           }\n           \n           \n            col = hsb2rgb(vec3(hue, sat,mag*lightness));\n             \n             }\n               \n               \n               \n                return col;\n            }\n            ";let matOptions={clearcoat:1,metalness:0,roughness:.3},vert={aux:"",displace:displace,nVec:nVec},frag={aux:fragAux,fragColor:fragColor},matUniforms={coloration:{type:"int",value:0,range:[{"Gaussian Curvature":0,"Mean Curvature":1,"Gauss Map":2}]},equipotentials:{type:"bool",value:!0,range:[]}},surface=new ComputeMaterial(computer,matUniforms,vert,frag,matOptions);surface.setName("Coloration");const derive=e=>{let n=e.vel,t=accel(e);return new dState(n,t)},integrator=new RungeKutta(derive,.05),iniState=new State(new Vector2(2,1),new Vector2(1,1)),curveOptions={length:10,segments:1024,radius:.05,tubeRes:8,color:16777215},iniCondGenerator=function(e,n=0){let t=new Vector2(-2,1),a=.4*Math.sin(n/3)-.5+e/40,r=new Vector2(Math.cos(a),Math.sin(a)).normalize();return new State(t,r)},optionGenerator=function(e){return{length:5,segments:100,radius:.03/(1+.3*e*(.3*e)),tubeRes:8,color:2836610}},range={min:-10,max:10},stop=function(e){return!1},geoSpray=new IntegralCurveSpray(integrator,parameterization,iniCondGenerator,optionGenerator,stop,range);geoSpray.tick=function(e,n){geoSpray.update(e)},geoSpray.addToUI=function(e){};const gaussian={computer:computer,surface:surface,spray:geoSpray};export default gaussian;