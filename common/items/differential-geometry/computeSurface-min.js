import{globals}from"../../../template/src/globals.js";import{ComputeSystem}from"../../gpu/ComputeSystem.js";import{CSQuad}from"../../gpu/displays/CSQuad.js";import{ComputeMaterial}from"../../materials/ComputeMaterial.js";import{colorConversion}from"../../shaders/colors/colorConversion.js";import{LinearFilter,NearestFilter}from"../../../3party/three/build/three.module.js";let equations={x:"(b+a*cos(u))*cos(v)",y:"(b+a*cos(u))*sin(v)",z:"a*sin(u)+0.5*cos(u)*sin(3.*v)*sin(time)"},domain={uMin:-3.14,uMax:3.14,vMin:-3.14,vMax:3.14};equations.addToUI=e=>{let n=e.addFolder("Equations");n.add(equations,"x").name("x(u,v)=").onChange((()=>{computer.recompile("point")})),n.add(equations,"y").name("y(u,v)=").onChange((()=>{computer.recompile("point")})),n.add(equations,"z").name("z(u,v)=").onChange((()=>{computer.recompile("point")}));let t=e.addFolder("Domain");t.add(domain,"uMin",-6.3,6.3,.01).onChange((()=>{computer.recompile("point")})),t.add(domain,"uMax",-6.3,6.3,.01).onChange((()=>{computer.recompile("point")})),t.add(domain,"vMin",-6.3,6.3,.01).onChange((()=>{computer.recompile("point")})),t.add(domain,"vMax",-6.3,6.3,.01).onChange((()=>{computer.recompile("point")}))},equations.addToScene=()=>{};let buildPointShader=()=>`\n            void main(){\n\n                 vec2 uv = gl_FragCoord.xy/res;\n                 \n                 float u = (float(${domain.uMax})-float(${domain.uMin}))/0.97*uv.x+float(${domain.uMin});\n                 float v = (float(${domain.vMax})-float(${domain.vMin}))/0.97*uv.y+float(${domain.vMin});\n                 \n                 float x = ${equations.x};\n                 float y = ${equations.y};\n                 float z = ${equations.z};\n                 \n                 vec3 pos = vec3(x,y,z);\n                 \n                 gl_FragColor = vec4(pos,1.);\n            }\n        `;const fetch="\n    vec3 fetch(sampler2D tex, ivec2 ij) {\n\n        return texelFetch(tex, ij, 0).xyz;\n    }\n    ",derivativeCalc="\n\n            vec3 texDerivativeCentral(sampler2D tex, ivec2 ij, ivec2 dir){\n                vec3 value0 = fetch( tex, ij - dir );\n                vec3 value1 = fetch( tex, ij + dir );\n                \n                float ep;\n                if(dir.x==1){\n                    ep=1./res.x;\n                }\n                else{\n                    ep=1./res.y;\n                }\n\n                float h = 2.*ep;\n                \n                vec3 tang = ( value1 - value0 ) / h;\n                \n                return tang;\n            }\n                \n            vec3 texDerivativeRight(sampler2D tex, ivec2 ij, ivec2 dir){\n          \n            \n                vec3 value0 = fetch( tex, ij  );\n                vec3 value1 = fetch( tex, ij + dir );\n                \n                float ep;\n                if(dir.x==1){\n                    ep=1./res.x;\n                }\n                else{\n                    ep=1./res.y;\n                }\n\n                float h = ep;\n                \n                vec3 tang = ( value1 - value0 ) / h;\n                \n                return tang;\n            }\n            \n            vec3 texDerivativeLeft(sampler2D tex, ivec2 ij, ivec2 dir){\n            \n                vec3 value0 = fetch( tex, ij -dir  );\n                vec3 value1 = fetch( tex, ij  );\n                \n                float ep;\n                if(dir.x==1){\n                    ep=1./res.x;\n                }\n                else{\n                    ep=1./res.y;\n                }\n\n                float h = ep;\n                \n                vec3 tang = ( value1 - value0 ) / h;\n                \n                return tang;\n            }\n            \n            \n\n            vec3 texDerivative( sampler2D tex, ivec2 ij, ivec2 dir ){\n                //need to worry about edge cases: what happens at the boundary of the texture?\n                return texDerivativeRight(tex,ij,dir);\n            }\n        ",tangentUShader=fetch+derivativeCalc+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            ivec2 dir = ivec2(1,0);\n            \n            vec3 posU = texDerivative(point, ij, dir);\n            \n            gl_FragColor = vec4(posU,0);\n        }\n        ",tangentVShader=fetch+derivativeCalc+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            ivec2 dir = ivec2(0,1);\n            \n            vec3 posV = texDerivative(point, ij, dir);\n            \n            gl_FragColor = vec4(posV,0);\n        }\n        ",normalVecShader=fetch+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            \n            vec3 tU = fetch(tangentU, ij);\n            vec3 tV = fetch(tangentV, ij);\n           \n            vec3 nVec = cross( tU, tV );\n            nVec = normalize( nVec );\n            \n            gl_FragColor=vec4(nVec, 0.);\n        }\n        ",firstFFShader=fetch+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            \n            vec3 tU = fetch(tangentU, ij);\n            vec3 tV = fetch(tangentV, ij);\n            \n            float E = dot( tU, tU );\n            float F = dot( tU, tV );\n            float G = dot( tV, tV );\n            \n            vec3 I = vec3(E,F,G);\n            \n            gl_FragColor=vec4( I, 0. );\n        }\n        ",secondFFShader=fetch+derivativeCalc+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            ivec2 eU = ivec2(1,0);\n            ivec2 eV = ivec2(0,1);\n           \n           //get the normal vector\n            vec3 nVec = fetch(normalVec, ij);\n            \n            //compute the second derivatives of the parameterization:\n            vec3 posUU = texDerivative(tangentU, ij, eU);\n            vec3 posUV = texDerivative(tangentU, ij, eV);\n            vec3 posVV = texDerivative(tangentV, ij, eV);\n            \n            float L = dot( posUU, nVec );\n            float M = dot( posUV, nVec );\n            float N = dot( posVV, nVec );\n            \n            vec3 II = vec3(L, M, N);\n            \n            gl_FragColor=vec4( II, 0. );\n        }\n        ",curvatureShader=fetch+"\n        void main(){\n            ivec2 ij = ivec2(gl_FragCoord.xy-vec2(0.5));\n            \n            vec3 I = fetch(firstFF, ij);\n            float E = I.x;\n            float F = I.y;\n            float G = I.z;\n            \n            vec3 II = fetch(secondFF, ij);\n            float L = II.x;\n            float M = II.y;\n            float N = II.z;\n            \n            float gaussCurvature = (L*N-M*M)/(E*G-F*F);\n            \n            float meanCurvature = (E*N-2.*F*M+G*L)/(2.*(E*G-F*F));\n            \n            gl_FragColor = vec4( gaussCurvature, meanCurvature, 0, 0);\n        }\n        ",variables=["point","tangentU","tangentV","normalVec","firstFF","secondFF","curvature"],shaders={point:buildPointShader,tangentU:tangentUShader,tangentV:tangentVShader,normalVec:normalVecShader,firstFF:firstFFShader,secondFF:secondFFShader,curvature:curvatureShader},uniforms={a:{type:"float",value:1,range:[0,2,.01]},b:{type:"float",value:2,range:[1,3,.01]},c:{type:"float",value:0,range:[-1,1,.01]}},options={res:[256,256],filter:LinearFilter};let computer=new ComputeSystem(variables,shaders,uniforms,options,globals.renderer);computer.setName("Parameters");let surfaceDisplay=new CSQuad(computer);const vertAux="",displace="\nvec3 displace( vec2 uv ){\n    return texture(point, uv).xyz;\n}\n",nVec="\n    vec3 nVec( vec2 uv ){\n        return texture(normalVec, uv).xyz;\n    }\n",fragAux=colorConversion,fragColor="\n            vec3 fragColor(){\n            \n            vec3 col;\n            float curv;\n            \n            //first: if we are gaussian mor mean curvature:\n            if(coloration < 2) {\n            \n            if( coloration == 0 ){\n                curv = texture(curvature, vUv).x;\n            }\n            if( coloration ==1 ){\n                 curv = texture(curvature, vUv).y;\n            }\n\n            float k = 2./3.1415*atan(2.*curv);\n            \n            float hue = 1.-(1.+k)/2.-0.2;\n\n            float sat = 0.5;\n           // sat =0.25*abs(k)+0.25;\n           \n           //change lightness to get dark areas:\n           float mag=1.;\n           if(equipotentials){\n                mag = 0.15*(pow(abs(sin(20.*k)),30.))+0.9;\n           }\n\n            col = hsb2rgb(vec3(hue, sat, 0.5*mag));\n            \n          }\n            \n         //otherwise, we are the gauss map:\n         //assign colors based on a sphere: white = north pole, black = south pole, hue = longitude   \n         else{\n         \n            vec3 nVec = texture(normalVec, vUv).xyz;\n            float phi = acos(nVec.z);\n            float theta = atan(nVec.y, nVec.x);\n            \n            float hue = theta/6.29;\n            float lightness = 0.5*phi/3.14+0.2;\n            float sat = 0.6*sin(phi);\n            \n           //equipotentials give spherical grid:\n           float mag=1.;\n           if(equipotentials){\n                float thetaLines = abs(sin(20.*theta));\n                float phiLines = abs(sin(20.*phi));\n                mag = 0.1*(pow(phiLines,30.))+0.1*(pow(thetaLines,30.))+0.9;\n           }\n           \n           \n            col = hsb2rgb(vec3(hue, sat,mag*lightness));\n             \n             }\n               \n               \n               \n                return col;\n            }\n            ";let matOptions={clearcoat:1,metalness:0,roughness:.3},vert={aux:"",displace:displace,nVec:nVec},frag={aux:fragAux,fragColor:fragColor},matUniforms={coloration:{type:"int",value:0,range:[{"Gaussian Curvature":0,"Mean Curvature":1,"Gauss Map":2}]},equipotentials:{type:"bool",value:!0,range:[]}},surface=new ComputeMaterial(computer,matUniforms,vert,frag,matOptions);surface.setName("Coloration");class PixelReader{constructor(e,n,t,a){this.computer=e,this.variable=n,this.i=t,this.j=a}addToScene(e){}addToUI(e){}tick(){console.log(this.computer.compute[this.variable].readPixel(this.i,this.j))}}let readout=new PixelReader(computer,"curvature",5,5);const computeSurface={eqn:equations,computer:computer,surface:surface};export default computeSurface;