import{ComputeSystem}from"../../gpu/ComputeSystem.js";import{ComputeParticles}from"../../materials/ComputeParticles.js";import{globals}from"../../../template/src/globals.js";import{randomFns}from"../../shaders/math/random.js";import{rotateR4}from"../../shaders/geometry/rotateR4.js";import{rk4_vec4 as rk4}from"../../shaders/odes/rk4.js";import{CSParticle}from"../../gpu/displays/CSParticle.js";import{colorConversion}from"../../shaders/colors/colorConversion.js";import{LinearFilter,NearestFilter}from"../../../3party/three/build/three.module.js";const res=[4096,2048],computeVariables=["pos"],computeOptions={res:res,filter:NearestFilter,resetSwitch:!0};let computeUniforms={a0:{type:"float",value:.75,range:[0,2,.01]},b0:{type:"float",value:.25,range:[0,2,.01]},c0:{type:"float",value:.25,range:[0,2,.01]},d0:{type:"float",value:.5,range:[0,2,.01]}};const ini="\n        void main() {\n                //normalized coords in (0,1)\n                vec2 uv = gl_FragCoord.xy/res;\n                \n                //get a random seed for the pixel\n                seed = randomSeed(gl_FragCoord.xy,1.);\n                \n                //grab a random vector in the cube:\n                float x = 2.*randomFloat()-1.;\n                float y = 2.*randomFloat()-1.;\n                float z = 2.*randomFloat()-1.;\n                float w = 2.*randomFloat()-1.;\n\n                \n                //make the initial position\n                vec4 iniPos = 0.0001*vec4(x,y,z,w)+vec4(a0,b0,c0,d0);\n           \n                //send result to data texture\n                gl_FragColor = iniPos;\n        }\n",vecField="\n\n      float F1( vec4 pos ){\n     \n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          float E = a*c + b*d;\n          \n          float t1 = ( 1. + a - b );\n          float t2 = ( 1. + c - d );\n          float t3 = ( b - c + E );\n          float t4 = ( d - a + E );\n          float t5 = a*b*c*d;\n          \n          return ( t1 * t2 * t3 * t4 ) / t5;\n     \n      }\n      \n      \n      float F2( vec4 pos ){\n     \n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          float E = a*c + b*d;\n          \n          float t1 = ( 1. + b - a );\n          float t2 = ( 1. + d - c );\n          float t3 = ( c - b + E );\n          float t4 = ( a - d + E );\n          float t5 = a*b*c*d;\n          \n          return ( t1 * t2 * t3 * t4 ) / t5;\n     \n      }\n      \n      \n      \n      float Phi( vec4 pos, vec2 invariants ){\n            vec2 vals = vec2( F1(pos), F2(pos) );\n            vec2 v = vals - invariants;\n            return dot(v,v);\n      }\n      \n      \n      //take the directional derivative of G in the direction dir:\n      float dDirPhi( vec4 pos, vec4 dir, vec2 invariants ){\n      \n        float eps =0.0001;\n        \n        float v0 = Phi( pos - eps*dir, invariants );\n        float v1 = Phi( pos + eps*dir, invariants );\n\n        return (v1-v0)/(2.*eps*length(dir));\n        \n      }\n      \n      \n      //compute the gradient of G\n      vec4 gradPhi( vec4 pos, vec2 invariants ) {\n      \n         vec4 ea = vec4(1,0,0,0);\n         vec4 eb = vec4(0,1,0,0);\n         vec4 ec = vec4(0,0,1,0);\n         vec4 ed = vec4(0,0,0,1);\n   \n         float dPhia = dDirPhi( pos, ea, invariants );\n         float dPhib = dDirPhi( pos, eb, invariants );\n         float dPhic = dDirPhi( pos, ec, invariants );\n         float dPhid = dDirPhi( pos, ed, invariants );\n         \n         vec4 grad = vec4( dPhia, dPhib, dPhic, dPhid );\n      \n        return grad;\n        \n      }\n      \n\n\n\n\n\n\n\n      float G( vec4 pos ){\n      \n         return F2(pos) - F1(pos);\n      \n      }\n      \n      //take the directional derivative of G in the direction dir:\n      float dDirG( vec4 pos, vec4 dir ){\n      \n        float eps =0.0001;\n        \n        float v0 = G( pos - eps*dir );\n        float v1 = G( pos + eps*dir );\n\n        return (v1-v0)/(2.*eps*length(dir));\n        \n      }\n      \n      \n      // //compute the gradient of G\n      vec4 gradG( vec4 pos ) {\n\n         vec4 ea = vec4(1,0,0,0);\n         vec4 eb = vec4(0,1,0,0);\n         vec4 ec = vec4(0,0,1,0);\n         vec4 ed = vec4(0,0,0,1);\n\n         float dGa = dDirG( pos, ea );\n         float dGb = dDirG( pos, eb );\n         float dGc = dDirG( pos, ec );\n         float dGd = dDirG( pos, ed );\n\n         vec4 grad = vec4( dGa, dGb, dGc, dGd );\n\n        return grad;\n\n      }\n\n      \n      // vec4 gradG( vec4 pos ){\n      //\n      //     float a = pos.x;\n      //     float b = pos.y;\n      //     float c = pos.z;\n      //     float d = pos.w;\n      //\n      //     float dGa = (-2.*a*a*a*c*d + (-1. + b) * d * ((b - c)*(b - c) + (-1. + b*b) * c * d - b*b*d*d) + \n      //  a*a * (b + c * d * (-c + d) + b * (c - d) * (c * (-1. + d) + d)));\n      //\n      //\n      //     float dGb = (a * b *b * (-1. + c *c ) + (-2. * b*b*b + (-1. + a*a) * c * (a + c) + \n      //    b*b* (1. + 2.* c - a* (-1. + c + c*c))) * d + (c - \n      //    a*a*c + (1. - 2.*b)* b*b* c + a * b*b* (1. + 2.* c)) *d*d - (1. + a - \n      //    2.* b)* b*b*d*d*d);\n      //\n      //    float dGc = (a * b * (b + (b - 2. * c) * c*c - a * (1. + c*c)) + (-1. + \n      //    b) * (b * (-a + b) + (-1. + a*a - a * b)*c*c)*d + \n      // a * (a - b) * b * d *d + (a - b) * (-1. + b) * b * d *d*d);\n      //\n      //   float dGd = (a * b * (a - b + c) * (-1. + c*c) - ((-1. + b)*(-1.+b)* (1. + b) * c + \n      //    a*a* (b + (-1. + b) * c) + a * b * (c - b * (1. + 2. * c))) * d*d - \n      // 2. * (a - b) * (-1. + b) * b * d * d *d);\n      //\n      //   float coef = 0.;\n      //   if(a*b*c*d!=0.){\n      //       coef = 2./(a*b*c*d);\n      //       return coef*vec4( dGa/a, dGb/b, dGc/c, dGd/d );\n      //    }\n      //\n      //   return vec4(0);\n      //\n      // }\n      //\n      \n      //rotate a gradient with respect to symplectic form:\n      vec4 symplecticGrad(vec4 pos, vec4 grad){\n      \n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          \n          float gra = grad.x;\n          float grb = grad.y;\n          float grc = grad.z;\n          float grd = grad.w;\n          \n          return vec4( -a*b*grb, a*b*gra, -c*d*grd, c*d*grc );\n      \n      }\n      \n      \n      //do this for the function G\n      vec4 symplecticG( vec4 pos ) {\n     \n        vec4 grad = gradG(pos);\n        vec4 flow = symplecticGrad(pos, grad);\n        return flow;\n      }\n      \n      \n      \n      vec4 XG( vec4 pos ){\n      \n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          \n          \n          float Xa = -(a*b*(2.*(-2./a - (1. - a*a - b*b)/(a*b*b))*(a - b + c - d) - \n        2.*((1. - a*a - b*b)/(a*b) + (1. - c*c - d*d)/(c*d))));\n        \n        float Xb = a*b*(2.*(-2./b - (1. - a*a - b*b)/(a*a*b))*(a - b + c - d) + \n       2.*((1. - a*a - b*b)/(a*b) + (1. - c*c - d*d)/(c*d)));\n       \n       float Xc = -(c*d*(2.*(a - b + c - d)*(-2./c - (1. - c*c - d*d)/(c*d*d)) - \n        2.*((1. - a*a - b*b)/(a*b) + (1. - c*c - d*d)/(c*d))));\n        \n        \n        float Xd = c*d*(2.*(a - b + c - d)*(-2./d - (1. - c*c - d*d)/(c*c*d)) + \n       2.*((1. - a*a- b*b)/(a*b) + (1. - c*c- d*d)/(c*d)));\n      \n    \n        return vec4( Xa, Xb, Xc, Xd );\n      \n      }\n      \n      \n     \n      \n      vec4 X1(vec4 pos ){\n                 \n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          \n          float x = ((1. + c - d)*(-(a*pow(b,2.)) + a*c - pow(a,3.)*c + a*pow(b,2.)*c - a*pow(c,2.) + pow(a,3.)*pow(c,2.) -\n        2.*a*pow(b,2.)*d + 2.*pow(b,3.)*d - c*d + pow(a,2.)*c*d - pow(b,2.)*c*d + 2.*a*pow(b,2.)*c*d -\n        a*pow(b,2.)*pow(d,2.) + 2.*pow(b,3.)*pow(d,2.)))/(b*c*d);\n        \n        float y =   ((1. + c - d)*(-(pow(a,2.)*b) - 2.*pow(a,3.)*c + 2.*pow(a,2.)*b*c + 2.*pow(a,3.)*pow(c,2.) -\n        pow(a,2.)*b*pow(c,2.) - b*d - pow(a,2.)*b*d + pow(b,3.)*d + c*d + pow(a,2.)*c*d + 2.*pow(a,2.)*b*c*d -\n        pow(b,2.)*c*d - b*pow(d,2.) + pow(b,3.)*pow(d,2.)))/(a*c*d);\n        \n        float z =   ((1. + a - b)*(-(a*b) + a*c - pow(a,2.)*c + a*b*pow(c,2.) - a*pow(c,3.) + pow(a,2.)*pow(c,3.) -\n        a*b*pow(d,2.) - c*pow(d,2.) + a*c*pow(d,2.) - 2.*b*c*pow(d,2.) + 2.*a*b*c*pow(d,2.) -\n        pow(b,2.)*c*pow(d,2.) + 2.*b*pow(d,3.) + 2.*pow(b,2.)*pow(d,3.)))/(a*b*d);\n        \n        float w = ((1. + a - b)*(a*b + a*b*pow(c,2.) - 2.*a*pow(c,3.) + 2.*pow(a,2.)*pow(c,3.) - b*d - pow(b,2.)*d -\n        pow(c,2.)*d + 2.*a*pow(c,2.)*d - pow(a,2.)*pow(c,2.)*d - b*pow(c,2.)*d + 2.*a*b*pow(c,2.)*d -\na*b*pow(d,2.) + b*pow(d,3.) + pow(b,2.)*pow(d,3.)))/(a*b*c);\n        \n        return vec4(x,y,z,w);\n        \n        }\n\n\n\n    \n    vec4 vecField( vec4 pos ) {\n    \n        // vec2 invariants = vec2(invP, invQ);\n        //\n        // vec4 grad = - gradPhi( pos, invariants );\n        // vec4 flow = symplecticG( pos );\n        //\n        // return (1.-gradSpeed)*flow + gradSpeed*grad;\n        \n        \n        return X1(pos);\n        \n    }\n    ",discreteDynamics="\n    vec4 A(vec4 pos){\n    \n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          \n          return vec4(-b,-a,-d,-c);\n    \n    }\n    \n    vec4 Delta(vec4 pos){\n          float a = pos.x;\n          float b = pos.y;\n          float c = pos.z;\n          float d = pos.w;\n          \n          float E = a*c + b*d;\n          float D = (E + a + c + 1.);\n          \n          float x = b*(c+d+1.);\n          float y = d*(E+b+c);\n          float z = d*(a+b+1.);\n          float w = b*(E+a+d);\n          \n          return vec4(x/(c*D), y/(c*D), z/(a*D), w/(a*D));\n          \n    }\n    \n    vec4 discreteDynamics(vec4 pos){\n        return A(Delta(pos));\n        }\n",sim=discreteDynamics+'\n\n    vec4 jump(vec4 p ){\n                \n                float x = randomFloat();\n            if(x<0.5){\n                 return discreteDynamics(p);   \n                }\n                \n                return p;\n    }\n    \n\nvoid main()\n        //takes in gl_FragCoord, outputs gl_FragColor\n        {   \n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = gl_FragCoord.xy/res;\n            ivec2 ij = ivec2(gl_FragCoord.xy);\n            \n            //random seed if needed:\n            seed = randomSeed(gl_FragCoord.xy, frameNumber);\n            \n            //get data from the last frame\n            //vec4 p = texture( pos, uv );\n            vec4 p = texelFetch(pos, ij, 0);\n           \n            \n            //apply the discrete dynamics:\n            vec4 q = p;\n            for(int i=0;i<8;i++){\n            q = jump(q);\n            }\n\n\n         \n            //update via RK, using the provided vecField\n            //vec4 q = rk4(p, dt);\n    \n             \n            \n            //if the resulting point is "out of bounds", restart it\n            //by randomly sampling the texture to get another point, and then perturbing:\n            // if(length(q)>20.){\n            //\n            //     vec2 samplePt = vec2(randomFloat(), randomFloat());\n            //     vec4 samplePos = texture( pos, samplePt );\n            //     vec4 jiggle = vec4(randomFloat(-1.,1.), randomFloat(-1.,1.), randomFloat(-1.,1.), randomFloat(-1.,1.));\n            //\n            //   //  q =  samplePos + 0.01 * jiggle;\n            //   q=samplePos;\n            //\n            // }\n\n            // Output to data texture\n            gl_FragColor = q;\n        }\n',posIni=randomFns+ini,posSim=randomFns+vecField+rk4+sim,computeShaders={pos:{initialization:posIni,simulation:posSim}},computePos=new ComputeSystem(computeVariables,computeShaders,computeUniforms,computeOptions,globals.renderer);computePos.setName("Integrator");const testParticles=new CSParticle(computePos),particleUniforms={size:{type:"float",value:1,range:[1,2,.01]},rot1:{type:"float",value:0,range:[.6,3,.01]},rot2:{type:"float",value:0,range:[.6,3,.01]},rot3:{type:"float",value:0,range:[.6,3,.01]}},particleVertex=rotateR4+"\n\nvarying vec3 particlePosition;\nvarying float particleProjection;\n\nvoid main() {\n\n    //the mesh is a square so the uvs = the xy positions of the vertices\n    //get the output of the compute shader\n    vec4 computePos = texture2D(pos, position.xy);\n    \n    //set the particlePosition and speed from this:\n    vec4 rotPos = rotateR4(computePos, rot1, rot2, rot3);\n    particlePosition = rotPos.xyz;\n    particleProjection = rotPos.w;\n \n    //regular projection of our position\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( particlePosition, 1.0 );\n \n    //sets the point size\n    gl_PointSize = size;\n}",particleFragment=colorConversion+'\nvarying vec3 particlePosition;\nvarying float particleProjection;\n\nvoid main() {\n\n    //need to learn how the key word "discard" works!\n    vec2 circCoord = 2.0 * gl_PointCoord - 1.0;\n      float d = dot(circCoord, circCoord);\n      if (d > 1.0) {\n          discard;\n      }\n    \n    //set the opacity of the point:\n    float opacity =0.15;\n    \n    //figure out the color of the point:\n    float x = 1./3.14*atan(particleProjection/4.)+0.5;\n    vec3 col = hsb2rgb(vec3(x,0.5,0.5));\n      \n    gl_FragColor = vec4( col, opacity );\n}',options={},particleDisplay=new ComputeParticles(computePos,particleUniforms,particleVertex,particleFragment,options);particleDisplay.setName("Particles");const pentagramMap={compute:computePos,display:particleDisplay};export default pentagramMap;