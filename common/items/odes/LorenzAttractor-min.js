import{ComputeSystem}from"../../gpu/ComputeSystem.js";import{ComputeParticles}from"../../materials/ComputeParticles.js";import{globals}from"../../World/globals.js";import{randomFns}from"../../shaders/math/random.js";import{rk4_vec3 as rk4}from"../../shaders/odes/rk4.js";import{CSParticle}from"../../gpu/displays/CSParticle.js";import{NearestFilter}from"../../../3party/three/build/three.module.js";const res=[1024,1024],computeVariables=["pos"],computeOptions={res:res,filter:NearestFilter,resetSwitch:!0};let computeUniforms={sigma:{type:"float",value:10,range:[9,11,.001]},beta:{type:"float",value:2.6666,range:[1,5,.001]},rho:{type:"float",value:28,range:[23,32,.001]}};const ini="\n        void main() {\n                //normalized coords in (0,1)\n                vec2 uv = gl_FragCoord.xy/res;\n                ivec2 ij = ivec2(gl_FragCoord.xy);\n                \n                //get a random seed for the pixel\n                seed = randomSeed(gl_FragCoord.xy,1.);\n                \n                //grab a random unit vector for each pixel:\n                vec3 sph = randomUnitVec3();\n                \n                //make a random point in the ball instead:\n                float x = randomFloat();\n                float rad=1.;\n                // if(InitialCond==0){\n                //    rad = gaussian();\n                // }\n                // else if(InitialCond==1){\n                //     rad = pow(x,1.333);\n                // }\n                // else{\n                //     rad = 1.;\n                // }\n                vec3 ball = sph*rad;\n                \n                //make the initial position\n                vec3 iniPos = 1.*sph + vec3(0.,0.,2.);\n           \n                //send result to data texture\n                gl_FragColor = vec4(iniPos,1.0);\n        }\n",vecField="\n    //choose the vector field based on a uniform: chooseAttractor\n    \n    vec3 vecField( vec3 pos ) {\n   \n                float x = pos.x;\n                float y = pos.y;\n                float z = pos.z;\n                    \n                float vx = sigma*(y-x);\n                float vy = x*(rho-z)-y;\n                float vz = x*y-beta*z;\n                \n                return vec3(vx,vy,vz);\n    }\n    ",sim="\n\nfloat dt = 0.01;\nvoid main()\n        //takes in gl_FragCoord, outputs gl_FragColor\n        {   \n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = gl_FragCoord.xy/res;\n            ivec2 ij = ivec2(gl_FragCoord.xy);\n            \n            //random seed if needed:\n            seed = randomSeed(gl_FragCoord.xy, frameNumber);\n            \n            //get data from the last frame\n            vec3 p = texelFetch( pos, ij, 0 ).xyz;\n         \n            //update via RK, using the provided vecField\n            vec3 q = rk4(p, dt);\n            \n            //get the speed at this point:\n            float speed = length(vecField(q));\n\n            // Output to data texture\n            gl_FragColor = vec4(q, 1.);\n        }\n",posIni=randomFns+ini,posSim=randomFns+vecField+rk4+sim,computeShaders={pos:{initialization:posIni,simulation:posSim}},computePos=new ComputeSystem(computeVariables,computeShaders,computeUniforms,computeOptions,globals.renderer);computePos.setName("Integrator");const testParticles=new CSParticle(computePos),particleUniforms={},particleVertex="\n\nvarying vec3 particlePosition;\nvarying float particleSpeed;\n\nvoid main() {\n\n    //the mesh is a square so the uvs = the xy positions of the vertices\n    //get the output of the compute shader\n    vec4 computePos = texture2D(pos, position.xy);\n    \n    //set the particlePosition and speed from this:\n    particlePosition = computePos.xyz;\n    particleSpeed = computePos.w;\n \n    //regular projection of our position\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( particlePosition, 1.0 );\n \n    //sets the point size\n    gl_PointSize = 1.;\n}",particleFragment='\nvarying vec3 particlePosition;\nvarying float particleSpeed;\n\nvoid main() {\n\n    //need to learn how the key word "discard" works!\n    vec2 circCoord = 2.0 * gl_PointCoord - 1.0;\n      float d = dot(circCoord, circCoord);\n      if (d > 1.0) {\n          discard;\n      }\n    \n    //set the opacity of the point:\n    float opacity =0.15;\n    \n    //figure out the color of the point:\n    vec3 col = particlePosition;\n      \n    gl_FragColor = vec4( vec3(1), opacity );\n}',options={},particleDisplay=new ComputeParticles(computePos,particleUniforms,particleVertex,particleFragment,options);particleDisplay.setName("Particles");const strangeAttractors={compute:computePos,display:particleDisplay};export default strangeAttractors;