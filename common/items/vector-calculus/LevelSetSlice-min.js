import{MeshPhysicalMaterial,PlaneBufferGeometry,SphereBufferGeometry,Mesh,Vector3,DoubleSide}from"../../../3party/three/build/three.module.js";import{Rod}from"../../components/basic-shapes/Rod.js";import Graph3D from"../../components/vector-calculus/Graph3D.js";import ContourPlotOld from"../../components/vector-calculus/ContourPlotOld.js";import ContourPlot2D from"../../components/vector-calculus/ContourPlot2D.js";let planeMaterial=new MeshPhysicalMaterial({side:DoubleSide,transparent:!0,transmission:.95,clearcoat:1,ior:1}),surfaceOptions={clearcoat:1,roughness:.4},pointMaterial=new MeshPhysicalMaterial({});class LevelSetSlice{constructor(){this.range={u:{min:-10,max:10},v:{min:-10,max:10}},this.params={animate:!0,slice:0,eqn:"2.*(cos(u)+sin(u*v/5.))"},this.uniforms={slice:{type:"float",value:this.params.slice}},this.contourColor="\n            vec3 colorFn(float z){\n              \n              if(abs(z-slice)<0.1){\n                return vec3(0.8,0.8,0);\n              }\n              \n              return vec3(0.03,vUv);\n            }\n        ",this.surfaceColor="\n            vec3 colorFn(vec2 uv, vec3 xyz){\n            \n             \n             float grid1 = (1.-pow(abs(sin(10.*3.14*uv.x)*sin(10.*3.14*uv.y)),0.1))/10.;\n             float grid2 = (1.-pow(abs(sin(50.*3.14*uv.x)*sin(50.*3.14*uv.y)),0.1))/25.;\n             float grid3 = (1.-pow(abs(sin(100.*3.14*uv.x)*sin(100.*3.14*uv.y)),0.1))/50.;\n             float grid = grid1+grid2+grid3;\n           \n                float height = xyz.y;\n                if(abs(height-slice)<0.1){\n                    return vec3(0.8,0.8,0);\n              }\n              else if(height-slice<0.){\n                return vec3(0.08,0.08,0.2)+vec3(grid);\n              }\n              return vec3(0.08,0.2,0.08)+vec3(grid);\n            }\n        ",this.graph=new Graph3D(this.params.eqn,this.range,this.uniforms,this.surfaceColor,surfaceOptions),this.contour=new ContourPlot2D(this.params.eqn,this.range,this.uniforms,this.contourColor),this.contour.setPosition(0,-7,0);let e=new SphereBufferGeometry(.4),t=new PlaneBufferGeometry(20,20);this.slicePlane=new Mesh(t,planeMaterial),this.slicePlane.rotateX(Math.PI/2),this.slicePoint=new Mesh(e,pointMaterial),this.axis=new Rod({end1:new Vector3(0,-5,0),end2:new Vector3(0,5,0)})}setSlice(e){this.params.slice=e,this.slicePlane.position.set(0,e,0),this.slicePoint.position.set(0,e,0),this.contour.update({slice:e}),this.graph.update({slice:e})}addToScene(e){this.graph.addToScene(e),this.contour.addToScene(e),this.axis.addToScene(e),e.add(this.slicePoint),e.add(this.slicePlane)}addToUI(e){let t=this;e.add(t.params,"animate").name("Animate"),e.add(t.params,"eqn").name("Equation").onFinishChange((function(e){t.contour.setFunction(e),t.graph.setFunction(e)})),e.add(t.params,"slice",-5,5,.01).name("Slice").onChange((function(e){t.setSlice(e)}))}tick(e,t){if(this.params.animate){let t=5*Math.sin(e/3);this.setSlice(t)}}}let ex=new LevelSetSlice;export default{ex:ex};