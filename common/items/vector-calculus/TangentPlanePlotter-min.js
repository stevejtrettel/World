import{MeshPhysicalMaterial,DoubleSide,Vector3,SphereBufferGeometry,Mesh}from"../../../3party/three/build/three.module.js";import DomainPlot from"../../components/vector-calculus/DomainPlot.js";import ParametricSurface from"../../components/parametric/ParametricSurface.js";import ParametricCurveCPU from"../../components/parametric/ParametricCurveCPU.js";import ParametricSurfaceCPU from"../../components/parametric/ParametricSurfaceCPU.js";import{Rod}from"../../components/basic-shapes/Rod.js";let surfaceOptions={clearcoat:1,roughness:.1},glassOptions={clearcoat:2,transparent:!0,transmission:.9,ior:1.5,color:16777215,roughness:0,side:DoubleSide,uRes:3,vRes:3};const parser=math.parser();class PartialDerivativePlotter{constructor(){this.params={uMin:0,uMax:3.14,vMin:-3.14,vMax:3.14,showPos:!0,uPos:.5,vPos:.5,animate:!0,xEqn:"2.*sin(u)*cos(v)",yEqn:"2.*cos(u)",zEqn:"2.*sin(u)*sin(v)",a:0,b:0,c:0},this.xEqn=this.params.xEqn,this.yEqn=this.params.yEqn,this.zEqn=this.params.zEqn,this.range={u:{min:this.params.uMin,max:this.params.uMax},v:{min:this.params.vMin,max:this.params.vMax}},this.tangentRange={u:{min:-2,max:2},v:{min:-2,max:2}},this.rescaleU=function(a){return this.range.u.min+(this.range.u.max-this.range.u.min)*a},this.rescaleV=function(a){return this.range.v.min+(this.range.v.max-this.range.v.min)*a},this.uniforms={showPos:{type:"bool",value:this.params.showPos},uPos:{type:"float",value:this.params.uPos},vPos:{type:"float",value:this.params.vPos},a:{type:"float",value:this.params.a},b:{type:"float",value:this.params.b},c:{type:"float",value:this.params.c}},this.domainColor="\n           vec3 colorFn(vec2 uv){\n                      float grid1 = (1.-pow(abs(sin(10.*3.14*uv.x)*sin(10.*3.14*uv.y)),0.1))/10.;\n             float grid2 = (1.-pow(abs(sin(50.*3.14*uv.x)*sin(50.*3.14*uv.y)),0.1))/25.;\n             float grid3 = (1.-pow(abs(sin(100.*3.14*uv.x)*sin(100.*3.14*uv.y)),0.1))/50.;\n             float grid = grid1+grid2+grid3;\n             \n             vec3 base =  0.6 + 0.4*cos(2.*3.14*uv.xyx+vec3(0,2,4));\n             vec3 final = base + 2.*vec3(grid);\n             \n   \n              //have to flip vPos around\n              //because we have switched y and z for vector calc students:\n              float newV = 1.-vPos;\n              \n              \n                if(abs(uv.x-uPos)<0.01){\n                    final=vec3(0.7,0.05,0.1);\n                }\n                if(abs(uv.y-newV)<0.01){\n                    final=vec3(0.1,0.05,0.7);\n                }\n                if(length(uv-vec2(uPos,newV))<0.02){\n                    final=vec3(0);\n                }\n             \n             \n             return final;\n           }\n        ",this.surfaceColor="\n           vec3 colorFn(vec2 uv, vec3 xyz){\n\n                      float grid1 = (1.-pow(abs(sin(10.*3.14*uv.x)*sin(10.*3.14*uv.y)),0.1))/10.;\n             float grid2 = (1.-pow(abs(sin(50.*3.14*uv.x)*sin(50.*3.14*uv.y)),0.1))/25.;\n             float grid3 = (1.-pow(abs(sin(100.*3.14*uv.x)*sin(100.*3.14*uv.y)),0.1))/50.;\n             float grid = grid1+grid2+grid3;\n             \n             vec3 base =  0.6 + 0.4*cos(2.*3.14*uv.xyx+vec3(0,2,4));\n             vec3 final = base + 2.*vec3(grid);\n             \n\n                if(abs(uv.x-uPos)<0.005){\n                    final=vec3(0.7,0.05,0.1);\n                }\n                if(abs(uv.y-vPos)<0.005){\n                    final=vec3(0.1,0.05,0.7);\n                }\n   \n            return final;\n             \n           }\n        ",this.surface=new ParametricSurface(this.buildGLSLEquation(),this.range,this.uniforms,this.surfaceColor,surfaceOptions),this.domainPlot=new DomainPlot(this.params.eqn,this.range,this.uniforms,this.domainColor),this.domainPlot.setPosition(0,-4,0),this.buildJSEquation(),this.tangentPlane=new ParametricSurfaceCPU(this.tangentEqn,this.tangentRange,glassOptions);let a=this.uEqn(this.params.uPos,this.params),n=this.uDerivative(this.params.uPos,this.params),e=(new Vector3).addVectors(a,n.clone().multiplyScalar(this.tangentRange.u.min)),t=(new Vector3).addVectors(a,n.clone().multiplyScalar(this.tangentRange.u.max));this.uTangent=new Rod({end1:e,end2:t,radius:.05,color:69093078}),a=this.uEqn(this.params.vPos,this.params),n=this.uDerivative(this.params.vPos,this.params),e=(new Vector3).addVectors(a,n.clone().multiplyScalar(this.tangentRange.v.min)),t=(new Vector3).addVectors(a,n.clone().multiplyScalar(this.tangentRange.v.max)),this.vTangent=new Rod({end1:e,end2:t,radius:.05,color:14032414});let s=new MeshPhysicalMaterial({clearcoat:1,color:0}),i=new SphereBufferGeometry(.12,32,16);this.point=new Mesh(i,s),this.point.position.set(a.x,a.y,a.z)}buildGLSLEquation(){return`vec3 eqn( vec2 uv ){\n        \n            float u = uv.x;\n            float v = uv.y;\n            \n            float x = ${this.params.xEqn};\n            float y = ${this.params.yEqn};\n            float z = ${this.params.zEqn};\n           \n            vec3 end = vec3(x,y,z);\n           \n            return end;\n            \n       }`}buildJSEquation(){let a=this,n=parser.evaluate("xEqn(u,v,time,a,b,c)=".concat(this.xEqn)),e=parser.evaluate("yEqn(u,v,time,a,b,c)=".concat(this.yEqn)),t=parser.evaluate("zEqn(u,v,time,a,b,c)=".concat(this.zEqn));this.eqn=function(a,s,i={time:0,a:0,b:0,c:0,uPos:0,vPos:0}){let o=n(a,s,i.time,i.a,i.b,i.c),r=e(a,s,i.time,i.a,i.b,i.c),u=t(a,s,i.time,i.a,i.b,i.c);return new Vector3(o,r,u)},this.uEqn=function(n,e={time:0,a:0,b:0,c:0,uPos:0,vPos:0}){return a.eqn(n,a.rescaleV(e.vPos),e)},this.uDerivative=function(n,e={time:0,a:0,b:0,c:0,uPos:0,vPos:0}){let t=.001,s=a.uEqn(n-t,e),i=a.uEqn(n+t,e);return(new Vector3).subVectors(i,s).divideScalar(.002)},this.vEqn=function(n,e={time:0,a:0,b:0,c:0,uPos:0,vPos:0}){return a.eqn(a.rescaleU(e.uPos),n,e)},this.vDerivative=function(n,e={time:0,a:0,b:0,c:0,uPos:0,vPos:0}){let t=.001,s=a.vEqn(n-t,e),i=a.vEqn(n+t,e);return(new Vector3).subVectors(i,s).divideScalar(.002)},this.tangentEqn=function(n,e,t={time:0,a:0,b:0,c:0,uPos:0,vPos:0}){let s=a.eqn(a.rescaleU(t.uPos),a.rescaleV(t.vPos),t),i=a.uDerivative(a.rescaleU(t.uPos),t).normalize(),o=a.vDerivative(a.rescaleV(t.vPos),t).normalize();return s.addScaledVector(i,n).addScaledVector(o,e)}}updateTangents(){let a=this.rescaleU(this.params.uPos),n=this.uEqn(a,this.params),e=this.uDerivative(a,this.params).normalize(),t=(new Vector3).addVectors(n,e.clone().multiplyScalar(this.tangentRange.u.min)),s=(new Vector3).addVectors(n,e.clone().multiplyScalar(this.tangentRange.u.max));this.uTangent.resize(t,s);let i=this.rescaleV(this.params.vPos);n=this.vEqn(i,this.params),e=this.vDerivative(i,this.params).normalize(),t=(new Vector3).addVectors(n,e.clone().multiplyScalar(this.tangentRange.v.min)),s=(new Vector3).addVectors(n,e.clone().multiplyScalar(this.tangentRange.v.max)),this.vTangent.resize(t,s),this.point.position.set(n.x,n.y,n.z),this.tangentPlane.setEqn(this.tangentEqn),this.tangentPlane.update(this.params)}addToScene(a){this.surface.addToScene(a),this.domainPlot.addToScene(a),this.uTangent.addToScene(a),this.vTangent.addToScene(a),this.tangentPlane.addToScene(a),a.add(this.point)}addToUI(a){let n=this;a.add(n.params,"xEqn").name("x(u,v)=").onFinishChange((function(a){n.params.xEqn=a,n.xEqn=a;let e=n.buildGLSLEquation();n.surface.setFunction(e),n.buildJSEquation(),n.updateTangents()})),a.add(n.params,"zEqn").name("y(u,v)=").onFinishChange((function(a){n.params.zEqn=a,n.zEqn=a;let e=n.buildGLSLEquation();n.surface.setFunction(e),n.buildJSEquation(),n.updateTangents()})),a.add(n.params,"yEqn").name("z(u,v)=").onFinishChange((function(a){n.params.yEqn=a,n.yEqn=a;let e=n.buildGLSLEquation();n.surface.setFunction(e),n.buildJSEquation(),n.updateTangents()}));let e=a.addFolder("Domain");e.add(n.params,"uMin",-10,10,.01).onChange((function(a){n.range.u.min=a,n.surface.setDomain(n.range),n.domainPlot.setDomain(n.range)})),e.add(n.params,"uMax",-10,10,.01).onChange((function(a){n.range.u.max=a,n.surface.setDomain(n.range),n.domainPlot.setDomain(n.range)})),e.add(n.params,"vMin",-10,10,.01).onChange((function(a){n.range.v.min=a,n.surface.setDomain(n.range),n.domainPlot.setDomain(n.range)})),e.add(n.params,"vMax",-10,10,.01).onChange((function(a){n.range.v.max=a,n.surface.setDomain(n.range),n.domainPlot.setDomain(n.range)}));let t=a.addFolder("Parameters");t.add(n.params,"a",-1,1,.01).onChange((function(a){n.surface.update({a:a})})),t.add(n.params,"b",-1,1,.01).onChange((function(a){n.surface.update({b:a})})),t.add(n.params,"c",-1,1,.01).onChange((function(a){n.surface.update({c:a})})),a.add(n.params,"uPos",0,1,.01).name("u0").onChange((function(a){n.params.uPos=a,n.surface.update({uPos:a}),n.domainPlot.update({uPos:a}),n.buildJSEquation(),n.updateTangents()})),a.add(n.params,"vPos",0,1,.01).name("v0").onChange((function(a){n.params.vPos=a,n.surface.update({vPos:a}),n.domainPlot.update({vPos:a}),n.buildJSEquation(),n.updateTangents()})),a.add(n.params,"animate")}tick(a,n){this.params.animate&&(this.buildJSEquation(),this.params.uPos=.25*Math.sin(a)+.5,this.params.vPos=.25*Math.sin(a/3)+.5,this.surface.update({uPos:this.params.uPos,vPos:this.params.vPos}),this.domainPlot.update({uPos:this.params.uPos,vPos:this.params.vPos}),this.updateTangents())}}let ex=new PartialDerivativePlotter;export default{ex:ex};