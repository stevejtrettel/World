import ParametricSurface from"../../components/parametric/ParametricSurface.js";let surfaceOptions={clearcoat:1,roughness:.4};class ParametricSurfacePlotter{constructor(){this.range={u:{min:0,max:6.29},v:{min:0,max:6.29}},this.params={uMin:0,uMax:6.29,vMin:0,vMax:6.29,animate:!1,homotopy:1,xEqn:"(1.25 *(1.-v/(2.*3.14159))*cos(2.*v)*(1.+cos(u))+cos(2.*v))",yEqn:"(10.*v/(2.*3.14159)+(1.-v/(2.*3.14159))*sin(u))-5.",zEqn:"-(1.25 *(1.-v/(2.*3.14159))*sin(2.*v)*(1.+cos(u))+sin(2.*v))",a:0,b:0,c:0},this.uniforms={homotopy:{type:"float",value:this.params.homotopy},a:{type:"float",value:this.params.a},b:{type:"float",value:this.params.b},c:{type:"float",value:this.params.c}},this.surfaceColor="\n            vec3 colorFn(vec2 uv, vec3 xyz){\n             \n             float grid1 = (1.-pow(abs(sin(10.*3.14*uv.x)*sin(10.*3.14*uv.y)),0.1))/10.;\n             float grid2 = (1.-pow(abs(sin(50.*3.14*uv.x)*sin(50.*3.14*uv.y)),0.1))/25.;\n             float grid3 = (1.-pow(abs(sin(100.*3.14*uv.x)*sin(100.*3.14*uv.y)),0.1))/50.;\n             float grid = grid1+grid2+grid3;\n             \n             vec3 base =  0.6 + 0.4*cos(2.*3.14*uv.xyx+vec3(0,2,4));\n             \n             return base + 2.*vec3(grid);\n            }\n        ",this.surface=new ParametricSurface(this.buildEquation(),this.range,this.uniforms,this.surfaceColor,surfaceOptions)}buildEquation(){return`vec3 eqn( vec2 uv ){\n        \n            float u = uv.x*homotopy;\n            float v = uv.y*homotopy;\n            \n            float x = ${this.params.xEqn};\n            float y = ${this.params.yEqn};\n            float z = ${this.params.zEqn};\n            \n            \n            //JUST FOR ANIMATION: OTHERWISE RETURN XYZ\n            //find the "basepoint" so the surface stays fixed in space\n            u=0.;\n            v=0.;\n            float x0 = ${this.params.xEqn};\n            float y0 = ${this.params.yEqn};\n            float z0 = ${this.params.zEqn};\n            \n            //rescale surface\n            return (vec3(x,y,z)-vec3(x0,y0,z0))/homotopy+vec3(x0,y0,z0);\n            \n            \n       }`}addToScene(a){this.surface.addToScene(a)}addToUI(a){let n=this;a.add(n.params,"xEqn").name("x(u,v)=").onFinishChange((function(a){n.params.xEqn=a;let e=n.buildEquation();n.surface.setFunction(e)})),a.add(n.params,"yEqn").name("y(u,v)=").onFinishChange((function(a){n.params.yEqn=a;let e=n.buildEquation();n.surface.setFunction(e)})),a.add(n.params,"zEqn").name("z(u,v)=").onFinishChange((function(a){n.params.zEqn=a;let e=n.buildEquation();n.surface.setFunction(e)}));let e=a.addFolder("Domain");e.add(n.params,"uMin",-10,10,.01).onChange((function(a){n.range.u.min=a,n.surface.setDomain(n.range)})),e.add(n.params,"uMax",-10,10,.01).onChange((function(a){n.range.u.max=a,n.surface.setDomain(n.range)})),e.add(n.params,"vMin",-10,10,.01).onChange((function(a){n.range.v.min=a,n.surface.setDomain(n.range)})),e.add(n.params,"vMax",-10,10,.01).onChange((function(a){n.range.v.max=a,n.surface.setDomain(n.range)}));let t=a.addFolder("Parameters");t.add(n.params,"a",-1,1,.01).onChange((function(a){n.surface.update({a:a})})),t.add(n.params,"b",-1,1,.01).onChange((function(a){n.surface.update({b:a})})),t.add(n.params,"c",-1,1,.01).onChange((function(a){n.surface.update({c:a})}));let o=a.addFolder("Homotopy");o.add(n.params,"animate").name("Animate"),o.add(n.params,"homotopy",0,1,.01).name("Homotopy").onChange((function(a){n.surface.update({homotopy:a})}))}tick(a,n){if(this.params.animate){let n=(1+Math.cos(a/2))/2;this.surface.update({homotopy:n})}else this.surface.update({homotopy:1})}}let ex=new ParametricSurfacePlotter;export default{ex:ex};