import{globals}from"../../World/globals.js";import{DoubleSide,LinearFilter,MeshPhysicalMaterial,BoxBufferGeometry,Mesh,NearestFilter,PlaneBufferGeometry}from"../../../3party/three/build/three.module.js";import{complex}from"../../shaders/math/complex.js";import{colorConversion}from"../../shaders/colors/colorConversion.js";import TextureShader from"../../gpu/components/TextureShader.js";const toUV="\n    vec2 toUV(vec2 pixelCoords){\n        return vec2(pixelCoords.x/res.x,pixelCoords.y/res.y);\n    }\n    ",toCoords="\n    vec2 toCoords( vec2 uv ){\n    \n        float spreadX = (xMax-xMin);\n        float spreadY = (yMax-yMin);\n        float x = spreadX*uv.x + xMin;\n        float y = spreadY*uv.y + yMin;\n\n        return vec2(x,y);\n    }\n";let createGLSLFunction=function(e){return"\n    vec2 f( vec2 z ){\n        return "+e+";}"};const newtonMethodFunction="\nvec2 fPrime( vec2 z ){\n    float eps = 0.0001;\n    \n    //if the function is complex differentiable the limit exists and\n    //is equal along all directions approaching zero: so, approach along real axis!\n    vec2 df = f(z+vec2(eps/2.,0))-f(z-vec2(eps/2.,0));\n    \n    return df/eps;\n}\n\nvec2 newton( vec2 z ){\n    vec2 val = f(z);\n    vec2 deriv = fPrime(z);\n    vec2 adjust = cdiv(val,deriv);\n    \n    vec2 z1 = z - adjust;\n    return z1;\n}\n\nvec2 newtonIteration( vec2 z, int n ){\n\n    for(int i=0; i<n; i++){\n        z = newton(z);\n    }\n    \n    return z;\n   \n}\n",mainShaderFn="\n    void main(){\n    \n        //get coordinates from fragCoord:\n        vec2 uv = toUV( gl_FragCoord.xy );\n        vec2 z = toCoords(uv);\n        \n        //run newton's iteration at z:\n        vec2 w = newtonIteration(z, 20);\n        \n        //map w to a color value:\n        //check if we have converged, by applying newton one more time\n        vec3 color;\n        vec2 v = newton(w);\n        if(length(v-w)>0.0001){\n            color = vec3(0);\n        }\n        else{\n            //the system has converged: choose a color based on w:\n            color = vec3(w.x,w.y,0);\n        }\n    \n        //return this to the shader\n        gl_FragColor = vec4(color,1);\n     }\n";class NewtonFractal{constructor(e,n,t,o){this.res=[4096,4096],this.range=o,this.uniforms=n,this.f=e,this.uniformString=t,this.constantString="\n        float xMin = -10.;\n        float xMax = 10.;\n        float yMin = -10.;\n        float yMax = 10.;\n        vec2 res = vec2(4096,4096);\n        ";let r=createGLSLFunction(e),a=this.constantString+complex+toUV+toCoords+r+newtonMethodFunction+mainShaderFn,i={res:this.res,filter:NearestFilter};this.texShader=new TextureShader(a,this.uniforms,this.uniformString,i,globals.renderer);let s=new MeshPhysicalMaterial({side:DoubleSide,clearcoat:1});s.map=null;let l=new PlaneBufferGeometry(1,1);this.plane=new Mesh(l,s);let c=this.range.x.max-this.range.x.min,h=this.range.y.max-this.range.y.min;this.plane.scale.set(c,h,1),this.plane.rotateX(-Math.PI/2),this.plane.rotateZ(Math.PI)}setPosition(e,n,t){this.plane.position.set(e,n,t)}addToScene(e){e.add(this.plane)}update(e){this.texShader.updateUniforms(e),this.texShader.run(),this.plane.material.map=this.texShader.getData()}setFunction(e){let n=createGLSLFunction(e),t=this.constantString+complex+toUV+toCoords+n+newtonMethodFunction+mainShaderFn;this.texShader.recompile(t)}}export default NewtonFractal;