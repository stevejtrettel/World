<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>ThreeJS World</title>

    <!--  CSS -->
    <link rel="stylesheet" type="text/css" href="./css/main.css" media="screen" />

    <!--  Mathjax-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script> window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
    </script>


<body>

<!--Our World Scene goes Here!-->
<div id="World">
</div>

<div id="info" >

    <h2>Differential Geometry:</h2>
    <h1>The Curvature of Surfaces</h1>
    <p id="moreDetails"><b style = 'font-size:28px'>+</b></p>

    <!--  <i class='fas fa-chevron-down' style='font-size:18px'></i>-->
    <div id="details" class="hidden">

        <p>This program illustrates the  <a href = "https://en.wikipedia.org/wiki/Differential_geometry_of_surfaces" target = 'blank'>
            differential geometry </a> of surfaces in Euclidean 3-space.
            The menu (accessible via the + in upper right) has options to enter a parameterization of the form
            $\Phi(u,v)= \left(x(u,v),\, y(u,v),\, z(u,v)\right)$.
            The default surface is a deformation of a torus of revolution:
        </p>

        $$\Phi(u,v)=
        \left\{
        \begin{aligned}
        &(b+a\cos(u))\cos(v) \\
        &(b+a\cos(u))\sin(v)\\
        & a\sin(v)+\tfrac{\sin(time)}{2}\cos(u)\sin(3v)
        \end{aligned}
        \right.
        $$

        <p>The symbols $a,b,c$ and $time$ may be used in the definition of $\Phi$ as parameters;  with $a,b,c$
            controllable by sliders in the menu.
            The surface may be colored to illustrate the intrinsic curvatures and the Gauss map, described below.
        </p>

        <br>
        <h3>Gaussian Curvature</h3>
        The  <a href = "https://en.wikipedia.org/wiki/Gaussian_curvature" target = 'blank'>
        gaussian curvature </a> of a surface is an intrinsic invariant, and can be computed from an embedding as the product
        of the two  <a href = "https://en.wikipedia.org/wiki/Principal_curvature" target = 'blank'>
        principal curvatures</a> at a point.  The color schema here represents positive curature as red, running through
        the rainbow to negative curvature as purple.


        <br><br>
        <h3>Mean Curvature</h3>
        The  <a href = "https://en.wikipedia.org/wiki/Mean_curvature" target = 'blank'>
        mean curvature </a> of an oriented surface is an intrinsic invariant, and can be computed from an embedding as the sum
        of the two  <a href = "https://en.wikipedia.org/wiki/Principal_curvature" target = 'blank'>
        principal curvatures</a> at a point.  The color schema here is the same as for gaussian curvature.


        <br><br>
        <h3>The Gauss Map</h3>
        Given an embedded surface $\Sigma\hookrightarrow\mathbb{R}^3$, the  <a href = "https://en.wikipedia.org/wiki/Gauss_map" target = 'blank'>
        gauss map </a> of the embedding is the induced map $\Sigma\to\mathbb{S}^2$  which sends each point on the surface to its unit normal, on the unit sphere.
        The coloration here is a pullback of sphere, colored with longitudianal ange mapped to hue,
        and latitude to lightness (white near north pole, black near the south). The gridlines are a pullback of the standard spherical coordinate grid on $\mathbb{S}^2$.

    </div>


<!--    <div id="statsToggle"><p><b>+</b></p></div>-->
    <div id="statsFolder"></div>



</div>



<p id="signature"><a href="http://www.stevejtrettel.site" > stevejtrettel</a> </p>

<!-- Math Parser Engine -->
<script src="./3party/math.js"></script>

<!-- Make the More Details Box Expandable-->
<script src = "./css/moreDetails.js"></script>



<!-- Our Javascript Program -->
<script  type="module">

    //set the objects that will run in this simulation
    import { computeSurface } from "./common/items/computeSurface.js";
    let objects = { ...computeSurface };

    let options={};

    //the function which builds a world from the default template,
    //using these objects
    import { mainFromTemplate } from "./template/mainFromTemplate.js";
    //call the function to run the app
    mainFromTemplate(objects,options);

</script>

<!--<script src="./main.js" type="module"></script>-->




</body>
</html>
